在有三辆以上车在换道流程中时退出程序或者重新加载场景都会卡死
	1.跟换道行为有关
	2.可能跟资源释放有关
	3.有没有可能有莫名的空引用？
		但是为什么两辆车换道时没有问题？（偶尔两辆车换道也有问题，可能是有其他车辆刚刚进入换道状态）

	为什么跟数量有关？我能想到的就只是资源释放的问题。但是既然两辆车不会卡死，为什么超过两辆车就会卡死？？  
	有没有可能是destory方法的问题？destory方法删除在一帧最后，退出时重复删除？
	有时候多辆车换道时重新加载也没事，为啥啊？？？？？？？？
	还有可能跟触发器有关？？

MissingReferenceException: The object of type 'Car' has been destroyed but you are still trying to access it.
Your script should either check if it is null or you should not destroy the object.
Car.judgeLocation (Car pointer, Car target) (at Assets/Scripts/Car.cs:154)
Car.findNextCar (Line l) (at Assets/Scripts/Car.cs:172)
Car.changeLine (Line l) (at Assets/Scripts/Car.cs:183)
ChangeLine.OnEnd () (at Assets/Scripts/CarBehaviorTree/Action/ChangeLine.cs:53)
BehaviorDesigner.Runtime.BehaviorManager.PopTask (BehaviorDesigner.Runtime.BehaviorManager+BehaviorTree behaviorTree, System.Int32 taskIndex, System.Int32 stackIndex, BehaviorDesigner.Runtime.Tasks.TaskStatus& status, System.Boolean popChildren, System.Boolean notifyOnEmptyStack) (at <2d6030ccee254a9eaa5111e162446e21>:0)
BehaviorDesigner.Runtime.BehaviorManager.DestroyBehavior (BehaviorDesigner.Runtime.Behavior behavior, BehaviorDesigner.Runtime.Tasks.TaskStatus executionStatus) (at <2d6030ccee254a9eaa5111e162446e21>:0)
BehaviorDesigner.Runtime.BehaviorManager.DisableBehavior (BehaviorDesigner.Runtime.Behavior behavior, System.Boolean paused, BehaviorDesigner.Runtime.Tasks.TaskStatus executionStatus) (at <2d6030ccee254a9eaa5111e162446e21>:0)
BehaviorDesigner.Runtime.BehaviorManager.DisableBehavior (BehaviorDesigner.Runtime.Behavior behavior, System.Boolean paused) (at <2d6030ccee254a9eaa5111e162446e21>:0)
BehaviorDesigner.Runtime.Behavior.DisableBehavior () (at <2d6030ccee254a9eaa5111e162446e21>:0)
BehaviorDesigner.Runtime.Behavior.OnDisable () (at <2d6030ccee254a9eaa5111e162446e21>:0)
	
	解决：
		行为树插件的问题，行为树节点中OnEnd()方法在退出时必定调用。切换场景调用destory这就会导致就算依附的car销毁了，这个方法仍然会调用。
		OnEnd方法中会按照上面的堆栈调用方法，这时car==null触发空引用异常。

		这里面有一个奇特的点是，OnEnd里面第一步调用car.changeLine（非静态方法），此时car已经被销毁了，报错应该就在这一层，但是却深入到了对car本身的空引用时才报错。
		猜测跟unity对同引用的内存布局有关？虽然changeLine是非静态方法，但是可能所有的car的changeLine方法共享同一地址，因为指令重排对内存的优化使得只是在传参时加上car实例？
		因为对car实例第一次真正的地址访问是在judgeLocation里面，所以堆栈信息跟踪到了最下层的judgeLocation方法里面，最外层看起来就是调用null.changeLine
		
	涉及到面向对象类设计的内存分布了
